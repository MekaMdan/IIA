# -*- coding: utf-8 -*-
"""Trabalho3_IIA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PldCFFCH56vXzwQ_0iFqQXXcTX7rhl6X
"""

import pandas as pd

"""Pandas é uma biblioteca para trabalhar com leitura e manipulação de dados. Utilizamos para leitura do arquivo de dados disponibilizado."""

dataframe = pd.read_excel("dataset.xlsx")

dataframe

"""Devido a presença de campos com o valor NaN, vamos substituir esses valores por 0 para realizar o treinamento das árvores."""

dataframe = dataframe.fillna(0)

"""# Exploração de Dados
A função describe() do pandas foi utilizada para mostrar uma visão geral a respeito dos dados estatísticos presentes na tabela. 

A função info() apresenta dados sobre a tabela em si (tipos de campos presentes, quantidade de colunas, etc).
"""

dataframe.describe()

dataframe.info()

"""Acessamos a coluna que contém o diagnóstico final e atribuimos à variável diagnostic."""

diagnostic = dataframe[["SARS-Cov-2 exam result"]]

diagnostic

"""# Pré processamento dos dados

Removemos todas as colunas que não são do tipo numérico visto que a função de treino da floresta randômica não sabe lidar com dados do tipo *string*.
"""

cols_to_remove = []

for col in dataframe.columns:
    try:
        _ = dataframe[col].astype(float)
    except ValueError:
        cols_to_remove.append(col)
        pass

# keep only the columns in dataframe that do not contain string
dataframe = dataframe[[col for col in dataframe.columns if col not in cols_to_remove]]

"""Verificando se todos as colunas restantes possuem valores numéricos e não nulos."""

dataframe.info()

"""Atribuimos à variável predictors os dados de laboratório, ou seja, os dados das colunas restantes com exceção da coluna de diagnóstico e das colunas removidas no pré processamento por conterem valores não numéricos."""

predictors = dataframe.drop(columns=['Patient addmited to regular ward (1=yes, 0=no)', 'Patient addmited to semi-intensive unit (1=yes, 0=no)','Patient addmited to intensive care unit (1=yes, 0=no)'])

predictors

"""# Divisão do conjunto de dados em Teste e Treino
Utilizamos a biblioteca train_test_split do sklearn para dividir os dados em 30% teste e 70% treino.
"""

from sklearn.model_selection import train_test_split

predictors_train, predictors_test, diagnostic_train, diagnostic_test = train_test_split(predictors, diagnostic, test_size=0.30, random_state=88)

"""A função train_test_split() com o 

*   Item da lista
*   Item da lista

parâmetro test_size=0.30 retorna 4 valores que são 4 dataframes da respectiva ordem: 

*  70% dos dados para construir as árvores (preditores),
*  30% dos dados para teste (predictors_test),
*  os diagnósticos referentes aos 70% dos dados preditores (diagnostic_train) 
* e os diagnósticos referentes aos 30% dos dados de teste (diagnostic_test).

# Declaração da *Random Forest* e treinamento dela com os dados de treino
"""

from sklearn.ensemble import RandomForestClassifier

rf_model = RandomForestClassifier(n_estimators=100)

rf_model.fit(predictors_train,diagnostic_train)

"""# Verificando a relevância das colunas dos preditores

Para verificar as 10 colunas (testes/variáveis) mais relevantes para o diagnóstico final, criamos um dataframe com duas colunas (o nome da feature e a respectiva importância no modelo). Depois, ordenamos em ordem da maior para a menor.
"""

columns_relevance = pd.DataFrame({'feature': list(predictors.columns),
                   'importance': rf_model.feature_importances_}).\
                    sort_values('importance', ascending = False)

columns_relevance.head(n=10)

"""# Verificando a precisão da predição do diagnóstico dos pacientes

Importamos a função classification_report() da biblioteca sklearn para visualizar as diversas métricas de acurácia obtidas.
"""

from sklearn.metrics import classification_report

"""Usamos o método predict() para testar no nosso modelo criado e treinado (rf_model) o conjunto de 30% dos dados originais que foram separados para teste anteriormente."""

rf_predict = rf_model.predict(predictors_test)

"""O método classification_report() compara o rótulo objetivo (diagnóstico) do conjunto de 30% do original com as previsões do modelo. Por fim, imprimimos o resultado desse método."""

print(classification_report(diagnostic_test, rf_predict))

"""# Análise dos resultados obtidos

Pode-se observar que o nosso modelo consegue obter com 91% de precisão, os casos em que o diagnóstico é negativo para COVID-19. Além disso, obteve 100% de precisão para prever os casos positivos de COVID-19.

Entretanto, a métrica *recall* para o diagnóstico positivo está baixa, o que indica que os dados utilizados para o treinamento do modelo estão desbalanceados (existem muito mais diagnósticos negativos do que positivos no *dataframe* utilizado). Isso pode ser verificado ao realizar a contagem dos resultados dos diagnósticos (PCR).
"""

diagnostic.value_counts()

"""# Criação de nova coluna
A tabela dada pelo professor possui tres colunas boleanas para sinalizar se o paciente foi ou não internado em alguma das três alas do hospital. Porem, não apresenta dados para caso o paciente esteja fazendo acompanhamento em casa. Para isso, iremos adicionar uma coluna com valores de 0 a 3 para indicar se o paciente foi ou não internado, onde 


*   0 = acompanhados em casa
*   1 = internados na enfermaria
*   2 = internados em unidade semi-intensiva
e
*   3 = internados em unidade intensiva

Iremos deduzir que os pacientes que não foram internados nem na enfermaria, nem na unidade semi-intensiva e nem na unidade intensiva serão acompanhados em casa.
"""

def unit_selector(row):
  if row['Patient addmited to regular ward (1=yes, 0=no)'] == 1:
    return 1
  elif row['Patient addmited to semi-intensive unit (1=yes, 0=no)'] ==1:
    return 2
  elif row['Patient addmited to intensive care unit (1=yes, 0=no)'] == 1:
    return 3
  else :
    return 0

dataframe['addimited unit'] = dataframe.apply(lambda row:unit_selector(row), axis=1)

dataframe

"""# Previsão de ala

Analogamente, utilizamos como diagnóstico a coluna "addimited unit" para predizer em qual ala o paciente foi acompanhado: 1) internados em enfermaria, 2) internados em unidade semi-intensiva, 3) internados em unidade intensiva, 4) acompanhados em casa .
"""

diagnostic_ward = dataframe[["addimited unit"]]

diagnostic_ward

diagnostic_ward.value_counts()

"""O número de casos em que a pessoa foi acompanhada em casa é significativamente maior do que os outros."""

dataframe = dataframe.drop(columns=['Patient addmited to regular ward (1=yes, 0=no)', 'Patient addmited to semi-intensive unit (1=yes, 0=no)','Patient addmited to intensive care unit (1=yes, 0=no)', 'addimited unit'])

dataframe.info()

predictors_ward = dataframe

predictors

predictors_ward_train, predictors_ward_test, diagnostic_ward_train, diagnostic_ward_test = train_test_split(predictors_ward, diagnostic_ward, test_size=0.30, random_state=88)

rf_ward_model = RandomForestClassifier(n_estimators=100)

rf_ward_model.fit(predictors_ward_train,diagnostic_ward_train)

columns_relevance_ward = pd.DataFrame({'feature': list(predictors_ward.columns),
                   'importance': rf_ward_model.feature_importances_}).\
                    sort_values('importance', ascending = False)

columns_relevance_ward.head()

rf_predict_ward = rf_ward_model.predict(predictors_ward_test)

print(classification_report(diagnostic_ward_test, rf_predict_ward))

"""Podemos observar que podemos predizer com **98% de precisão** os casos em que o paciente tem que ser **acompanhado em casa**. Para os demais casos, obtemos as seguintes precisões: 

1. 0% de precisão para pacientes que devem ser internados em enfermaria 
2. 12% de precisão para pacientes que devem ser internados em unidade semi-intensiva
3. 100% de precisão para pacientes que devem ser internados em unidade intensiva

Entretanto, a métrica *recall* para a previsão do tipo de acompanhamento indicado está baixa para o casos 1, 2 e 3. Isso indica que os dados estão desbalanceados, visto que a Floresta Randômica (*Random Forest*) foi treinada com muito mais exemplos em que o paciente teria de ser acompanhado em casa.

Dessa forma, o único caso que podemos prever de forma segura é o caso em que o paciente tem que ser acompanhado em casa. Os demais apresentam níveis de acurácia muito abaixo do ideal. Considerando o contexto médico em que o algoritmo é utilizado, o ideal é que a acurácia fosse mais confiável para diagnosticar corretamente como o paciente deve ser acompanhado.

# Referências

*   Removendo strings de um dataframe: https://stackoverflow.com/questions/42335385/delete-every-column-that-contains-a-string-in-dataframe
*   Modelo do RandomForest do Scikit-learn: https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html
*   Leitura de arquivos Xlsx com pandas: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html
*   Verificando relevância das colunas: https://towardsdatascience.com/an-implementation-and-explanation-of-the-random-forest-in-python-77bf308a9b76
"""