# -*- coding: utf-8 -*-
"""Trabalho3_IIA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PldCFFCH56vXzwQ_0iFqQXXcTX7rhl6X
"""

import pandas as pd

"""Pandas é uma biblioteca para trabalhar com leitura e manipulação de dados. Utilizamos para leitura do arquivo de dados disponibilizado."""

dataframe = pd.read_excel("dataset.xlsx")

dataframe

"""Devido a presença de campos com o valor NaN, vamos substituir esses valores por 0 para realizar o treinamento das árvores."""

dataframe = dataframe.fillna(0)

"""# Exploração de Dados
A função describe() do pandas foi utilizada para mostrar uma visão geral a respeito dos dados estatísticos presentes na tabela. 

A função info() apresenta dados sobre a tabela em si (tipos de campos presentes, quantidade de colunas, etc).
"""

dataframe.describe()

dataframe.info()

"""Acessamos a coluna que contém o diagnóstico final e atribuimos à variável diagnostic."""

diagnostic = dataframe["SARS-Cov-2 exam result"]

"""# Pré processamento dos dados

Removemos todas as colunas que não são do tipo numérico visto que a função de treino da floresta randômica não sabe lidar com dados do tipo *string*.
"""

cols_to_remove = []

for col in dataframe.columns:
    try:
        _ = dataframe[col].astype(float)
    except ValueError:
        cols_to_remove.append(col)
        pass

# keep only the columns in dataframe that do not contain string
dataframe = dataframe[[col for col in dataframe.columns if col not in cols_to_remove]]

"""Verificando se todos as colunas restantes possuem valores numéricos e não nulos."""

dataframe.info()

"""Atribuimos à variável predictors os dados de laboratório, ou seja, os dados das colunas restantes com exceção da coluna de diagnóstico e das colunas removidas no pré processamento por conterem valores não numéricos."""

predictors = dataframe

predictors

"""# Divisão do conjunto de dados em Teste e Treino
Utilizamos a biblioteca train_test_split do sklearn para dividir os dados em 30% teste e 70% treino.
"""

from sklearn.model_selection import train_test_split

predictors_train, predictors_test, diagnostic_train, diagnostic_test = train_test_split(predictors, diagnostic, test_size=0.30, random_state=88)

"""A função train_test_split() com o parâmetro test_size=0.30 retorna 4 valores que são 4 dataframes da respectiva ordem: 

*  70% dos dados para construir as árvores (preditores),
*  30% dos dados para teste (predictors_test),
*  os diagnósticos referentes aos 70% dos dados preditores (diagnostic_train) 
* e os diagnósticos referentes aos 30% dos dados de teste (diagnostic_test).

# Declaração da *Random Forest* e treinamento dela com os dados de treino
"""

from sklearn.ensemble import RandomForestClassifier

rf_model = RandomForestClassifier(n_estimators=100)

rf_model.fit(predictors_train,diagnostic_train)

"""# Verificando a relevância das colunas dos preditores

Para verificar as 10 colunas (testes/variáveis) mais relevantes para o diagnóstico final, criamos um dataframe com duas colunas (o nome da feature e a respectiva importância no modelo). Depois, ordenamos em ordem da maior para a menor.
"""

columns_relevance = pd.DataFrame({'feature': list(predictors.columns),
                   'importance': rf_model.feature_importances_}).\
                    sort_values('importance', ascending = False)

columns_relevance.head(n=10)

"""# Verificando a precisão da predição do diagnóstico dos pacientes

Importamos a função classification_report() da biblioteca sklearn para visualizar as diversas métricas de acurácia obtidas.
"""

from sklearn.metrics import classification_report

"""Usamos o método predict() para testar no nosso modelo criado e treinado (rf_model) o conjunto de 30% dos dados originais que foram separados para teste anteriormente."""

rf_predict = rf_model.predict(predictors_test)

"""O método classification_report() compara o rótulo objetivo (diagnóstico) do conjunto de 30% do original com as previsões do modelo. Por fim, imprimimos o resultado desse método."""

print(classification_report(diagnostic_test, rf_predict))

"""# Análise dos resultados obtidos

Pode-se observar que o nosso modelo consegue obter com 91% de precisão, os casos em que o diagnóstico é negativo para COVID-19. Além disso, obteve 85% de precisão para prever os casos postivos de COVID-19.
"""

diagnostic.value_counts()

"""Entretanto, a métrica *recall* para o diagnóstico positivo está baixa, o que indica que os dados estão desbalanceados (existem muito mais diagnósticos negativos do que positivos). Isso pode ser verificado ao realizar a contagem dos resultados dos diagnósticos (PCR).

# Referências

*   Removendo strings de um dataframe: https://stackoverflow.com/questions/42335385/delete-every-column-that-contains-a-string-in-dataframe
*   Modelo do RandomForest do Scikit-learn: https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html
*   Leitura de arquivos Xlsx com pandas: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html
*   Verificando relevância das colunas: https://towardsdatascience.com/an-implementation-and-explanation-of-the-random-forest-in-python-77bf308a9b76
"""